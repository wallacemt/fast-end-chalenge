name: fast-end-cd

on:
  workflow_dispatch:
    inputs:
      environment:
        type: choice
        description: "Ambiente de deployment"
        required: true
        options:
          - prod
      imageTag:
        required: true
        description: "Deployment image tag"
        default: "latest"
      terraform-apply:
        required: true
        description: "Apply Terraform changes"
        default: "false"

jobs:
  preparation:
    name: "ğŸ”§ Preparation & Validation"
    runs-on: ubuntu-latest
    outputs:
      manager-ip: ${{ steps.tf-output.outputs.manager-ip }}
      worker1-ip: ${{ steps.tf-output.outputs.worker1-ip }}
      worker2-ip: ${{ steps.tf-output.outputs.worker2-ip }}
      terraform-changed: ${{ steps.tf-plan.outputs.changed }}
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: ğŸ› ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: ï¿½ Cache Terraform providers
        uses: actions/cache@v3
        with:
          path: |
            ~/.terraform.d/plugin-cache
            infra/terraform/.terraform
          key: terraform-${{ runner.os }}-${{ hashFiles('infra/terraform/*.tf') }}
          restore-keys: |
            terraform-${{ runner.os }}-

      - name: ï¿½ğŸ”‘ Setup SSH public key
        run: |
          echo "${{ secrets.SSH_PUBLIC_KEY }}" > /tmp/id_rsa.pub
          chmod 644 /tmp/id_rsa.pub

      - name: ğŸš€ Terraform Init
        working-directory: infra/terraform
        run: terraform init

      - name: ï¿½ Sync Terraform state with AWS reality
        working-directory: infra/terraform
        run: |
          echo "ğŸ”„ Refreshing Terraform state to match AWS reality..."
          terraform refresh -var="key_name=deployer" -var="public_key_path=/tmp/id_rsa.pub"

      - name: ï¿½ğŸ“¦ Import existing resources
        id: tf-import
        working-directory: infra/terraform
        continue-on-error: true
        run: |
          chmod +x import_existing.sh
          ./import_existing.sh
          import_exit_code=$?
          echo "import-exit-code=$import_exit_code" >> $GITHUB_OUTPUT

          # If import was successful, refresh state to get current IPs
          if [ $import_exit_code -eq 0 ]; then
            echo "âœ… Resources imported successfully, refreshing state..."
            terraform refresh -var="key_name=deployer" -var="public_key_path=/tmp/id_rsa.pub"
          else
            echo "âš ï¸ Import had issues (exit code: $import_exit_code)"
          fi

      - name: ğŸ“‹ Terraform Plan
        id: tf-plan
        working-directory: infra/terraform
        continue-on-error: true
        run: |
          terraform plan -detailed-exitcode \
            -var="key_name=deployer" \
            -var="public_key_path=/tmp/id_rsa.pub" \
            -out=tfplan
          plan_exit_code=$?
          echo "plan-exit-code=$plan_exit_code" >> $GITHUB_OUTPUT

          if [ $plan_exit_code -eq 2 ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
          elif [ "${{ steps.tf-import.outputs.import-exit-code }}" = "2" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "changed=false" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ“¤ Upload Terraform plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: infra/terraform/tfplan
          retention-days: 1
      - name: ğŸ” Get current infrastructure IPs
        id: tf-output
        working-directory: infra/terraform
        run: |
          echo "ğŸ” Getting IPs from Terraform state..."
          terraform output -json > tf.json
          cat tf.json

          manager_ip=$(jq -r '.swarm_public_ips.value[0]' tf.json)
          worker1_ip=$(jq -r '.swarm_public_ips.value[1]' tf.json)
          worker2_ip=$(jq -r '.swarm_public_ips.value[2]' tf.json)

          # If Terraform doesn't have the right IPs, get them directly from AWS
          if [ -z "$manager_ip" ] || [ "$manager_ip" = "null" ] || [ "$manager_ip" = "" ]; then
            echo "âš ï¸ Terraform state missing IPs, querying AWS directly..."
            
            # Get IPs directly from AWS using instance tags
            manager_ip=$(aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=swarm-node-0" "Name=instance-state-name,Values=running" \
              --query 'Reservations[0].Instances[0].PublicIpAddress' \
              --output text 2>/dev/null || echo "")
              
            worker1_ip=$(aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=swarm-node-1" "Name=instance-state-name,Values=running" \
              --query 'Reservations[0].Instances[0].PublicIpAddress' \
              --output text 2>/dev/null || echo "")
              
            worker2_ip=$(aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=swarm-node-2" "Name=instance-state-name,Values=running" \
              --query 'Reservations[0].Instances[0].PublicIpAddress' \
              --output text 2>/dev/null || echo "")
              
            echo "ğŸ” IPs from AWS API:"
            echo "   Manager: $manager_ip"
            echo "   Worker1: $worker1_ip" 
            echo "   Worker2: $worker2_ip"
          fi

          # Final validation
          if [ -z "$manager_ip" ] || [ "$manager_ip" = "null" ] || [ "$manager_ip" = "None" ]; then
            echo "âŒ Error: Cannot get Manager IP from Terraform or AWS"
            echo "Terraform output:"
            cat tf.json
            exit 1
          fi

          echo "manager-ip=$manager_ip" >> $GITHUB_OUTPUT
          echo "worker1-ip=$worker1_ip" >> $GITHUB_OUTPUT
          echo "worker2-ip=$worker2_ip" >> $GITHUB_OUTPUT

          echo "âœ… Final IPs:"
          echo "   Manager: $manager_ip"
          echo "   Worker1: $worker1_ip"
          echo "   Worker2: $worker2_ip"
  terraform-apply:
    name: "ğŸ—ï¸ Infrastructure Provisioning"
    runs-on: ubuntu-latest
    needs: preparation
    if: needs.preparation.outputs.terraform-changed == 'true' || inputs.terraform-apply == 'true'
    outputs:
      manager-ip: ${{ steps.tf-output.outputs.manager-ip }}
      worker1-ip: ${{ steps.tf-output.outputs.worker1-ip }}
      worker2-ip: ${{ steps.tf-output.outputs.worker2-ip }}
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: ğŸ› ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: ğŸ”‘ Setup SSH public key
        run: |
          echo "${{ secrets.SSH_PUBLIC_KEY }}" > /tmp/id_rsa.pub
          chmod 644 /tmp/id_rsa.pub

      - name: ğŸš€ Terraform Init
        working-directory: infra/terraform
        run: terraform init

      - name: ğŸ“¥ Download Terraform plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          path: infra/terraform/

      - name: âœ… Apply Terraform changes
        working-directory: infra/terraform
        continue-on-error: true
        run: |
          echo "ğŸ”„ Applying infrastructure changes..."
          terraform apply -auto-approve tfplan

      - name: ğŸ” Get updated infrastructure IPs
        id: tf-output
        working-directory: infra/terraform
        run: |
          terraform output -json > tf.json
          manager_ip=$(jq -r '.swarm_public_ips.value[0]' tf.json)
          worker1_ip=$(jq -r '.swarm_public_ips.value[1]' tf.json)
          worker2_ip=$(jq -r '.swarm_public_ips.value[2]' tf.json)

          echo "manager-ip=$manager_ip" >> $GITHUB_OUTPUT
          echo "worker1-ip=$worker1_ip" >> $GITHUB_OUTPUT
          echo "worker2-ip=$worker2_ip" >> $GITHUB_OUTPUT

          echo "ğŸ–¥ï¸ Updated Manager IP: $manager_ip"
          echo "ğŸ‘¥ Updated Worker IPs: $worker1_ip, $worker2_ip"

  ansible-preparation:
    name: "ğŸ“‹ Ansible Preparation"
    runs-on: ubuntu-latest
    needs: preparation
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
      - name: ï¿½ Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: ï¿½ğŸ“¦ Cache Python dependencies
        uses: actions/cache@v3
        id: cache-python
        with:
          path: |
            ~/.cache/pip
            ~/.local/lib/python3.11/site-packages
          key: ansible-deps-${{ runner.os }}-py3.11-${{ hashFiles('**/requirements.txt') }}-v1
          restore-keys: |
            ansible-deps-${{ runner.os }}-py3.11-
            ansible-deps-${{ runner.os }}-

      - name: ğŸ“¦ Cache Ansible collections
        uses: actions/cache@v3
        id: cache-ansible
        with:
          path: |
            ~/.ansible/collections
            ~/.ansible/galaxy_cache
          key: ansible-collections-${{ runner.os }}-v1
          restore-keys: |
            ansible-collections-${{ runner.os }}-

      - name: ğŸš€ Install Ansible and dependencies (cached)
        if: steps.cache-python.outputs.cache-hit != 'true'
        run: |
          echo "ğŸ“¦ Installing fresh dependencies..."
          sudo apt-get update -qq
          sudo apt-get install -qqy ansible python3-boto3
          pip3 install --user -r requirements.txt

      - name: âœ… Use cached dependencies
        if: steps.cache-python.outputs.cache-hit == 'true'
        run: |
          echo "âš¡ Using cached Python dependencies!"
          # Ensure ansible is in PATH
          export PATH="$HOME/.local/bin:$PATH"
          ansible --version

      - name: ğŸ­ Install Ansible collections (cached)
        if: steps.cache-ansible.outputs.cache-hit != 'true'
        run: |
          echo "ğŸ“¦ Installing fresh Ansible collections..."
          ansible-galaxy collection install --no-cache community.docker

      - name: âœ… Use cached collections
        if: steps.cache-ansible.outputs.cache-hit == 'true'
        run: |
          echo "âš¡ Using cached Ansible collections!"
          ansible-galaxy collection list community.docker

      - name: ğŸ“¤ Upload Ansible files
        uses: actions/upload-artifact@v4
        with:
          name: ansible-config
          path: infra/ansible/
          retention-days: 1

  application-deployment:
    name: "ğŸš€ Application Deployment"
    runs-on: ubuntu-latest
    needs:
      - preparation
      - ansible-preparation
      - terraform-apply
    if: always() && (needs.terraform-apply.result == 'success' || (needs.terraform-apply.result == 'skipped' && needs.preparation.result == 'success'))
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Determine IPs to use
        id: determine-ips
        run: |
          if [ "${{ needs.terraform-apply.result }}" = "success" ]; then
            manager_ip="${{ needs.terraform-apply.outputs.manager-ip }}"
            worker1_ip="${{ needs.terraform-apply.outputs.worker1-ip }}"
            worker2_ip="${{ needs.terraform-apply.outputs.worker2-ip }}"
            echo "ğŸ”„ Using updated IPs from Terraform apply"
          else
            manager_ip="${{ needs.preparation.outputs.manager-ip }}"
            worker1_ip="${{ needs.preparation.outputs.worker1-ip }}"
            worker2_ip="${{ needs.preparation.outputs.worker2-ip }}"
            echo "â™»ï¸ Using existing IPs from preparation"
          fi

          # Validate IPs are not empty or null
          if [ -z "$manager_ip" ] || [ "$manager_ip" = "null" ]; then
            echo "âŒ Error: Manager IP is empty or null"
            exit 1
          fi

          if [ -z "$worker1_ip" ] || [ "$worker1_ip" = "null" ]; then
            echo "âŒ Error: Worker1 IP is empty or null"
            exit 1
          fi

          if [ -z "$worker2_ip" ] || [ "$worker2_ip" = "null" ]; then
            echo "âŒ Error: Worker2 IP is empty or null"
            exit 1
          fi

          echo "manager-ip=$manager_ip" >> $GITHUB_OUTPUT
          echo "worker1-ip=$worker1_ip" >> $GITHUB_OUTPUT
          echo "worker2-ip=$worker2_ip" >> $GITHUB_OUTPUT

          echo "âœ… Validated IPs:"
          echo "   Manager: $manager_ip"
          echo "   Worker1: $worker1_ip"
          echo "   Worker2: $worker2_ip"

      - name: ğŸ“ Generate Ansible inventory
        run: |
          mkdir -p infra/ansible
          cat > infra/ansible/inventory.ini << EOF
          [managers]
          manager ansible_host=${{ steps.determine-ips.outputs.manager-ip }} ansible_user=ubuntu

          [workers]
          worker1 ansible_host=${{ steps.determine-ips.outputs.worker1-ip }} ansible_user=ubuntu
          worker2 ansible_host=${{ steps.determine-ips.outputs.worker2-ip }} ansible_user=ubuntu
          EOF

          echo "ğŸ“‹ Generated inventory:"
          cat infra/ansible/inventory.ini

      - name: ï¿½ğŸ”‘ Setup SSH configuration
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Add all IPs to known_hosts with timeout and error handling
          for ip in "${{ steps.determine-ips.outputs.manager-ip }}" "${{ steps.determine-ips.outputs.worker1-ip }}" "${{ steps.determine-ips.outputs.worker2-ip }}"; do
            echo "Scanning SSH key for $ip..."
            timeout 30 ssh-keyscan -H "$ip" >> ~/.ssh/known_hosts 2>/dev/null || echo "Warning: Could not scan SSH key for $ip, will use StrictHostKeyChecking=no"
          done

      - name: ğŸš€ Deploy application with Ansible
        working-directory: infra/ansible
        run: |
          echo "ğŸ¯ Deploying to Docker Swarm cluster..."
          echo "ğŸ“Š Target image: ${{ inputs.imageTag }}"

          ansible-playbook -i inventory.ini playbook.yml --private-key ~/.ssh/deploy_key --ssh-common-args='-o StrictHostKeyChecking=no'

      - name: âœ… Deployment Summary
        run: |
          echo "ğŸ‰ Deployment completed successfully!"
          echo "ğŸŒ Application deployed to:"
          echo "   - Manager: http://${{ steps.determine-ips.outputs.manager-ip }}"
          echo "   - Worker1: http://${{ steps.determine-ips.outputs.worker1-ip }}"
          echo "   - Worker2: http://${{ steps.determine-ips.outputs.worker2-ip }}"
          echo "ğŸ·ï¸ Image tag: ${{ inputs.imageTag }}"
          echo "ğŸ—ï¸ Infrastructure: ${{ needs.terraform-apply.result == 'success' && 'Updated' || 'Reused existing' }}"
