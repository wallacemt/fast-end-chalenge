name: fast-end-cd

on:
  workflow_dispatch:
    inputs:
      environment:
        type: choice
        description: "Ambiente de deployment"
        required: true
        options:
          - prod
      imageTag:
        required: true
        description: "Deployment image tag"
        default: "latest"
      terraform-apply:
        required: true
        description: "Apply Terraform changes"
        default: "false"

jobs:
  preparation:
    name: "ğŸ”§ Preparation & Validation"
    runs-on: ubuntu-latest
    outputs:
      manager-ip: ${{ steps.tf-output.outputs.manager-ip }}
      worker1-ip: ${{ steps.tf-output.outputs.worker1-ip }}
      worker2-ip: ${{ steps.tf-output.outputs.worker2-ip }}
      terraform-changed: ${{ steps.tf-plan.outputs.changed }}
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: ğŸ› ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: ï¿½ Cache Terraform providers
        uses: actions/cache@v3
        with:
          path: |
            ~/.terraform.d/plugin-cache
            infra/terraform/.terraform
          key: terraform-${{ runner.os }}-${{ hashFiles('infra/terraform/*.tf') }}
          restore-keys: |
            terraform-${{ runner.os }}-

      - name: ï¿½ğŸ”‘ Setup SSH public key
        run: |
          echo "${{ secrets.SSH_PUBLIC_KEY }}" > /tmp/id_rsa.pub
          chmod 644 /tmp/id_rsa.pub

      - name: ğŸš€ Terraform Init
        working-directory: infra/terraform
        run: terraform init

      - name: ğŸ“¦ Import existing resources
        id: tf-import
        working-directory: infra/terraform
        continue-on-error: true
        run: |
          chmod +x import_existing.sh
          ./import_existing.sh || echo "Some resources may not exist yet - continuing..."
          echo "exit_code=$?" >> $GITHUB_OUTPUT

      - name: ğŸ“‹ Terraform Plan
        id: tf-plan
        working-directory: infra/terraform
        continue-on-error: true
        run: |
          terraform plan -detailed-exitcode -var="key_name=deployer" -var="public_key_path=/tmp/id_rsa.pub" -out=tfplan
          echo "exit_code=$?" >> $GITHUB_OUTPUT

      - name: ğŸ“¤ Upload Terraform plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: infra/terraform/tfplan
          retention-days: 1

  terraform-apply:
    name: "ğŸ—ï¸ Infrastructure Provisioning"
    runs-on: ubuntu-latest
    needs: preparation
    if: needs.preparation.outputs.terraform-changed == 'true' || inputs.terraform-apply == 'true'
    outputs:
      manager-ip: ${{ steps.tf-output.outputs.manager-ip }}
      worker1-ip: ${{ steps.tf-output.outputs.worker1-ip }}
      worker2-ip: ${{ steps.tf-output.outputs.worker2-ip }}
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: ğŸ› ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: ğŸ”‘ Setup SSH public key
        run: |
          echo "${{ secrets.SSH_PUBLIC_KEY }}" > /tmp/id_rsa.pub
          chmod 644 /tmp/id_rsa.pub

      - name: ğŸš€ Terraform Init
        working-directory: infra/terraform
        run: terraform init

      - name: ğŸ“¥ Download Terraform plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          path: infra/terraform/

      - name: âœ… Apply Terraform changes
        working-directory: infra/terraform
        continue-on-error: true
        run: |
          echo "ğŸ”„ Applying infrastructure changes..."
          terraform apply -auto-approve tfplan

   
  ansible-preparation:
    name: "ğŸ“‹ Ansible Preparation"
    runs-on: ubuntu-latest
    needs: preparation
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Get current infrastructure IPs
        id: tf-output
        working-directory: infra/terraform
        run: |
          terraform output -json > tf.json
          manager_ip=$(jq -r '.swarm_public_ips.value[0]' tf.json)
          worker1_ip=$(jq -r '.swarm_public_ips.value[1]' tf.json)
          worker2_ip=$(jq -r '.swarm_public_ips.value[2]' tf.json)

          echo "manager-ip=$manager_ip" >> $GITHUB_OUTPUT
          echo "worker1-ip=$worker1_ip" >> $GITHUB_OUTPUT
          echo "worker2-ip=$worker2_ip" >> $GITHUB_OUTPUT

          echo "ğŸ–¥ï¸ Manager IP: $manager_ip"
          echo "ğŸ‘¥ Worker IPs: $worker1_ip, $worker2_ip"
        
      - name: ï¿½ Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: ï¿½ğŸ“¦ Cache Python dependencies
        uses: actions/cache@v3
        id: cache-python
        with:
          path: |
            ~/.cache/pip
            ~/.local/lib/python3.11/site-packages
          key: ansible-deps-${{ runner.os }}-py3.11-${{ hashFiles('**/requirements.txt') }}-v1
          restore-keys: |
            ansible-deps-${{ runner.os }}-py3.11-
            ansible-deps-${{ runner.os }}-

      - name: ğŸ“¦ Cache Ansible collections
        uses: actions/cache@v3
        id: cache-ansible
        with:
          path: |
            ~/.ansible/collections
            ~/.ansible/galaxy_cache
          key: ansible-collections-${{ runner.os }}-v1
          restore-keys: |
            ansible-collections-${{ runner.os }}-

      - name: ğŸš€ Install Ansible and dependencies (cached)
        if: steps.cache-python.outputs.cache-hit != 'true'
        run: |
          echo "ğŸ“¦ Installing fresh dependencies..."
          sudo apt-get update -qq
          sudo apt-get install -qqy ansible python3-boto3
          pip3 install --user -r requirements.txt

      - name: âœ… Use cached dependencies
        if: steps.cache-python.outputs.cache-hit == 'true'
        run: |
          echo "âš¡ Using cached Python dependencies!"
          # Ensure ansible is in PATH
          export PATH="$HOME/.local/bin:$PATH"
          ansible --version

      - name: ğŸ­ Install Ansible collections (cached)
        if: steps.cache-ansible.outputs.cache-hit != 'true'
        run: |
          echo "ğŸ“¦ Installing fresh Ansible collections..."
          ansible-galaxy collection install --no-cache community.docker

      - name: âœ… Use cached collections
        if: steps.cache-ansible.outputs.cache-hit == 'true'
        run: |
          echo "âš¡ Using cached Ansible collections!"
          ansible-galaxy collection list community.docker

      - name: ğŸ“¤ Upload Ansible files
        uses: actions/upload-artifact@v4
        with:
          name: ansible-config
          path: infra/ansible/
          retention-days: 1

  application-deployment:
    name: "ğŸš€ Application Deployment"
    runs-on: ubuntu-latest
    needs:
      - preparation
      - ansible-preparation
      - terraform-apply
    if: always() && (needs.terraform-apply.result == 'success' || (needs.terraform-apply.result == 'skipped' && needs.preparation.result == 'success'))
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“ Generate Ansible inventory
        run: |
          mkdir -p infra/ansible
          cat > infra/ansible/inventory.ini << EOF
          [managers]
          manager ansible_host=${{ steps.determine-ips.outputs.manager-ip }} ansible_user=ubuntu

          [workers]
          worker1 ansible_host=${{ steps.determine-ips.outputs.worker1-ip }} ansible_user=ubuntu
          worker2 ansible_host=${{ steps.determine-ips.outputs.worker2-ip }} ansible_user=ubuntu
          EOF

          echo "ğŸ“‹ Generated inventory:"
          cat infra/ansible/inventory.ini

      - name: ï¿½ğŸ”‘ Setup SSH configuration
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Add all IPs to known_hosts with timeout and error handling
          for ip in "${{ steps.determine-ips.outputs.manager-ip }}" "${{ steps.determine-ips.outputs.worker1-ip }}" "${{ steps.determine-ips.outputs.worker2-ip }}"; do
            echo "Scanning SSH key for $ip..."
            timeout 30 ssh-keyscan -H "$ip" >> ~/.ssh/known_hosts 2>/dev/null || echo "Warning: Could not scan SSH key for $ip, will use StrictHostKeyChecking=no"
          done

      - name: ğŸš€ Deploy application with Ansible
        working-directory: infra/ansible
        run: |
          echo "ğŸ¯ Deploying to Docker Swarm cluster..."
          echo "ğŸ“Š Target image: ${{ inputs.imageTag }}"

          ansible-playbook -i inventory.ini playbook.yml --private-key ~/.ssh/deploy_key --ssh-common-args='-o StrictHostKeyChecking=no'

      - name: âœ… Deployment Summary
        run: |
          echo "ğŸ‰ Deployment completed successfully!"
          echo "ğŸŒ Application deployed to:"
          echo "   - Manager: http://${{ steps.determine-ips.outputs.manager-ip }}"
          echo "   - Worker1: http://${{ steps.determine-ips.outputs.worker1-ip }}"
          echo "   - Worker2: http://${{ steps.determine-ips.outputs.worker2-ip }}"
          echo "ğŸ·ï¸ Image tag: ${{ inputs.imageTag }}"
          echo "ğŸ—ï¸ Infrastructure: ${{ needs.terraform-apply.result == 'success' && 'Updated' || 'Reused existing' }}"
