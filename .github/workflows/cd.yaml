name: fast-end-cd

on:
  workflow_dispatch:
    inputs:
      environment:
        type: choice
        description: "Ambiente de deployment"
        required: true
        options:
          - prod
      imageTag:
        required: true
        description: "Deployment image tag"
        default: "latest"
      terraform-apply:
        required: true
        description: "Apply Terraform changes"
        default: "false"

jobs:
  preparation:
    name: "ğŸ”§ Preparation & Validation"
    runs-on: ubuntu-latest
    outputs:
      manager-ip: ${{ steps.tf-output.outputs.manager-ip }}
      worker1-ip: ${{ steps.tf-output.outputs.worker1-ip }}
      worker2-ip: ${{ steps.tf-output.outputs.worker2-ip }}
      terraform-changed: ${{ steps.tf-plan.outputs.changed }}
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: ğŸ› ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: ğŸ”‘ Setup SSH public key
        run: |
          echo "${{ secrets.SSH_PUBLIC_KEY }}" > /tmp/id_rsa.pub
          chmod 644 /tmp/id_rsa.pub

      - name: ğŸš€ Terraform Init
        working-directory: infra/terraform
        run: terraform init

      - name: ğŸ“¦ Import existing resources
        id: tf-import
        working-directory: infra/terraform
        continue-on-error: true
        run: |
          chmod +x import_existing.sh
          ./import_existing.sh
          echo "import-exit-code=$?" >> $GITHUB_OUTPUT

      - name: ğŸ“‹ Terraform Plan
        id: tf-plan
        working-directory: infra/terraform
        continue-on-error: true
        run: |
          terraform plan -detailed-exitcode \
            -var="key_name=deployer" \
            -var="public_key_path=/tmp/id_rsa.pub" \
            -out=tfplan
          plan_exit_code=$?
          echo "plan-exit-code=$plan_exit_code" >> $GITHUB_OUTPUT

          if [ $plan_exit_code -eq 2 ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
          elif [ "${{ steps.tf-import.outputs.import-exit-code }}" = "2" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "changed=false" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ“¤ Upload Terraform plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: infra/terraform/tfplan
          retention-days: 1

      - name: ğŸ” Get current infrastructure IPs
        id: tf-output
        working-directory: infra/terraform
        run: |
          terraform output -json > tf.json
          manager_ip=$(jq -r '.swarm_public_ips.value[0]' tf.json)
          worker1_ip=$(jq -r '.swarm_public_ips.value[1]' tf.json)
          worker2_ip=$(jq -r '.swarm_public_ips.value[2]' tf.json)

          echo "manager-ip=$manager_ip" >> $GITHUB_OUTPUT
          echo "worker1-ip=$worker1_ip" >> $GITHUB_OUTPUT
          echo "worker2-ip=$worker2_ip" >> $GITHUB_OUTPUT

          echo "ğŸ–¥ï¸ Manager IP: $manager_ip"
          echo "ğŸ‘¥ Worker IPs: $worker1_ip, $worker2_ip"

  terraform-apply:
    name: "ğŸ—ï¸ Infrastructure Provisioning"
    runs-on: ubuntu-latest
    needs: preparation
    if: needs.preparation.outputs.terraform-changed == 'true' || inputs.terraform-apply == 'true'
    outputs:
      manager-ip: ${{ steps.tf-output.outputs.manager-ip }}
      worker1-ip: ${{ steps.tf-output.outputs.worker1-ip }}
      worker2-ip: ${{ steps.tf-output.outputs.worker2-ip }}
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: ğŸ› ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: ğŸ”‘ Setup SSH public key
        run: |
          echo "${{ secrets.SSH_PUBLIC_KEY }}" > /tmp/id_rsa.pub
          chmod 644 /tmp/id_rsa.pub

      - name: ğŸš€ Terraform Init
        working-directory: infra/terraform
        run: terraform init

      - name: ğŸ“¥ Download Terraform plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          path: infra/terraform/

      - name: âœ… Apply Terraform changes
        working-directory: infra/terraform
        run: |
          echo "ğŸ”„ Applying infrastructure changes..."
          terraform apply -auto-approve tfplan

      - name: ğŸ” Get updated infrastructure IPs
        id: tf-output
        working-directory: infra/terraform
        run: |
          terraform output -json > tf.json
          manager_ip=$(jq -r '.swarm_public_ips.value[0]' tf.json)
          worker1_ip=$(jq -r '.swarm_public_ips.value[1]' tf.json)
          worker2_ip=$(jq -r '.swarm_public_ips.value[2]' tf.json)

          echo "manager-ip=$manager_ip" >> $GITHUB_OUTPUT
          echo "worker1-ip=$worker1_ip" >> $GITHUB_OUTPUT
          echo "worker2-ip=$worker2_ip" >> $GITHUB_OUTPUT

          echo "ğŸ–¥ï¸ Updated Manager IP: $manager_ip"
          echo "ğŸ‘¥ Updated Worker IPs: $worker1_ip, $worker2_ip"

  ansible-preparation:
    name: "ğŸ“‹ Ansible Preparation"
    runs-on: ubuntu-latest
    needs: preparation
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“¦ Install Ansible and dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -qqy ansible python3-boto3 python3-pip
          pip3 install --no-cache-dir docker
          ansible-galaxy collection install --no-cache community.docker

      - name: ğŸ“¤ Upload Ansible files
        uses: actions/upload-artifact@v4
        with:
          name: ansible-config
          path: infra/ansible/
          retention-days: 1

  application-deployment:
    name: "ğŸš€ Application Deployment"
    runs-on: ubuntu-latest
    needs:
      - preparation
      - ansible-preparation
      - terraform-apply
    if: always() && (needs.terraform-apply.result == 'success' || (needs.terraform-apply.result == 'skipped' && needs.preparation.result == 'success'))
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Determine IPs to use
        id: determine-ips
        run: |
          if [ "${{ needs.terraform-apply.result }}" = "success" ]; then
            echo "manager-ip=${{ needs.terraform-apply.outputs.manager-ip }}" >> $GITHUB_OUTPUT
            echo "worker1-ip=${{ needs.terraform-apply.outputs.worker1-ip }}" >> $GITHUB_OUTPUT
            echo "worker2-ip=${{ needs.terraform-apply.outputs.worker2-ip }}" >> $GITHUB_OUTPUT
            echo "ğŸ”„ Using updated IPs from Terraform apply"
          else
            echo "manager-ip=${{ needs.preparation.outputs.manager-ip }}" >> $GITHUB_OUTPUT
            echo "worker1-ip=${{ needs.preparation.outputs.worker1-ip }}" >> $GITHUB_OUTPUT
            echo "worker2-ip=${{ needs.preparation.outputs.worker2-ip }}" >> $GITHUB_OUTPUT
            echo "â™»ï¸ Using existing IPs from preparation"
          fi

      - name: ğŸ“ Generate Ansible inventory
        run: |
          mkdir -p infra/ansible
          cat > infra/ansible/inventory.ini << EOF
          [managers]
          manager ansible_host=${{ steps.determine-ips.outputs.manager-ip }} ansible_user=ubuntu

          [workers]
          worker1 ansible_host=${{ steps.determine-ips.outputs.worker1-ip }} ansible_user=ubuntu
          worker2 ansible_host=${{ steps.determine-ips.outputs.worker2-ip }} ansible_user=ubuntu
          EOF

          echo "ğŸ“‹ Generated inventory:"
          cat infra/ansible/inventory.ini

      - name: ğŸ”‘ Setup SSH configuration
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Add all IPs to known_hosts with timeout and error handling
          for ip in "${{ steps.determine-ips.outputs.manager-ip }}" "${{ steps.determine-ips.outputs.worker1-ip }}" "${{ steps.determine-ips.outputs.worker2-ip }}"; do
            echo "Scanning SSH key for $ip..."
            timeout 30 ssh-keyscan -H "$ip" >> ~/.ssh/known_hosts 2>/dev/null || echo "Warning: Could not scan SSH key for $ip, will use StrictHostKeyChecking=no"
          done

      - name: ğŸš€ Deploy application with Ansible
        working-directory: infra/ansible
        run: |
          echo "ğŸ¯ Deploying to Docker Swarm cluster..."
          echo "ğŸ“Š Target image: ${{ inputs.imageTag }}"

          ansible-playbook -i inventory.ini playbook.yml --private-key ~/.ssh/deploy_key --ssh-common-args='-o StrictHostKeyChecking=no'

      - name: âœ… Deployment Summary
        run: |
          echo "ğŸ‰ Deployment completed successfully!"
          echo "ğŸŒ Application deployed to:"
          echo "   - Manager: http://${{ steps.determine-ips.outputs.manager-ip }}"
          echo "   - Worker1: http://${{ steps.determine-ips.outputs.worker1-ip }}"
          echo "   - Worker2: http://${{ steps.determine-ips.outputs.worker2-ip }}"
          echo "ğŸ·ï¸ Image tag: ${{ inputs.imageTag }}"
          echo "ğŸ—ï¸ Infrastructure: ${{ needs.terraform-apply.result == 'success' && 'Updated' || 'Reused existing' }}"
